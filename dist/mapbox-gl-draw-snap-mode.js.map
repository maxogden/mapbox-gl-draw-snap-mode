{"version":3,"file":"mapbox-gl-draw-snap-mode.js","mappings":"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","sources":["webpack://mapboxGlDrawSnapMode/webpack/universalModuleDefinition","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/extent/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/geojson-coords/flatten.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/geojson-coords/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/geojson-extent/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/geojson-normalize/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-flatten/dist/index.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/traverse/index.js","webpack://mapboxGlDrawSnapMode/webpack/bootstrap","webpack://mapboxGlDrawSnapMode/webpack/runtime/compat get default export","webpack://mapboxGlDrawSnapMode/webpack/runtime/define property getters","webpack://mapboxGlDrawSnapMode/webpack/runtime/hasOwnProperty shorthand","webpack://mapboxGlDrawSnapMode/webpack/runtime/make namespace object","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/constants.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/helpers/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bbox-polygon/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/invariant/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-point-in-polygon/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/meta/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/quickselect.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/rbush.js","webpack://mapboxGlDrawSnapMode/./node_modules/geojson-rbush/index.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/line-segment/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/line-intersect/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/polygon-to-line/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/boolean-disjoint/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/distance/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/bearing/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/destination/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/nearest-point-on-line/main.es.js","webpack://mapboxGlDrawSnapMode/./node_modules/@turf/midpoint/main.es.js","webpack://mapboxGlDrawSnapMode/./src/utils/index.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_point.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_line.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_polygon.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js","webpack://mapboxGlDrawSnapMode/./src/modes/snap_direct_select.js","webpack://mapboxGlDrawSnapMode/./src/utils/customDrawStyles.js","webpack://mapboxGlDrawSnapMode/./node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mapboxGlDrawSnapMode\"] = factory();\n\telse\n\t\troot[\"mapboxGlDrawSnapMode\"] = factory();\n})(this, function() {\nreturn ","module.exports = Extent;\n\nfunction Extent(bbox) {\n    if (!(this instanceof Extent)) {\n        return new Extent(bbox);\n    }\n    this._bbox = bbox || [Infinity, Infinity, -Infinity, -Infinity];\n    this._valid = !!bbox;\n}\n\nExtent.prototype.include = function(ll) {\n    this._valid = true;\n    this._bbox[0] = Math.min(this._bbox[0], ll[0]);\n    this._bbox[1] = Math.min(this._bbox[1], ll[1]);\n    this._bbox[2] = Math.max(this._bbox[2], ll[0]);\n    this._bbox[3] = Math.max(this._bbox[3], ll[1]);\n    return this;\n};\n\nExtent.prototype.equals = function(_) {\n    var other;\n    if (_ instanceof Extent) { other = _.bbox(); } else { other = _; }\n    return this._bbox[0] == other[0] &&\n        this._bbox[1] == other[1] &&\n        this._bbox[2] == other[2] &&\n        this._bbox[3] == other[3];\n};\n\nExtent.prototype.center = function(_) {\n    if (!this._valid) return null;\n    return [\n        (this._bbox[0] + this._bbox[2]) / 2,\n        (this._bbox[1] + this._bbox[3]) / 2]\n};\n\nExtent.prototype.union = function(_) {\n    this._valid = true;\n    var other;\n    if (_ instanceof Extent) { other = _.bbox(); } else { other = _; }\n    this._bbox[0] = Math.min(this._bbox[0], other[0]);\n    this._bbox[1] = Math.min(this._bbox[1], other[1]);\n    this._bbox[2] = Math.max(this._bbox[2], other[2]);\n    this._bbox[3] = Math.max(this._bbox[3], other[3]);\n    return this;\n};\n\nExtent.prototype.bbox = function() {\n    if (!this._valid) return null;\n    return this._bbox;\n};\n\nExtent.prototype.contains = function(ll) {\n    if (!ll) return this._fastContains();\n    if (!this._valid) return null;\n    var lon = ll[0], lat = ll[1];\n    return this._bbox[0] <= lon &&\n        this._bbox[1] <= lat &&\n        this._bbox[2] >= lon &&\n        this._bbox[3] >= lat;\n};\n\nExtent.prototype.intersect = function(_) {\n    if (!this._valid) return null;\n\n    var other;\n    if (_ instanceof Extent) { other = _.bbox(); } else { other = _; }\n\n    return !(\n      this._bbox[0] > other[2] ||\n      this._bbox[2] < other[0] ||\n      this._bbox[3] < other[1] ||\n      this._bbox[1] > other[3]\n    );\n};\n\nExtent.prototype._fastContains = function() {\n    if (!this._valid) return new Function('return null;');\n    var body = 'return ' +\n        this._bbox[0] + '<= ll[0] &&' +\n        this._bbox[1] + '<= ll[1] &&' +\n        this._bbox[2] + '>= ll[0] &&' +\n        this._bbox[3] + '>= ll[1]';\n    return new Function('ll', body);\n};\n\nExtent.prototype.polygon = function() {\n    if (!this._valid) return null;\n    return {\n        type: 'Polygon',\n        coordinates: [\n            [\n                // W, S\n                [this._bbox[0], this._bbox[1]],\n                // E, S\n                [this._bbox[2], this._bbox[1]],\n                // E, N\n                [this._bbox[2], this._bbox[3]],\n                // W, N\n                [this._bbox[0], this._bbox[3]],\n                // W, S\n                [this._bbox[0], this._bbox[1]]\n            ]\n        ]\n    };\n};\n","module.exports = function flatten(list) {\n    return _flatten(list);\n\n    function _flatten(list) {\n        if (Array.isArray(list) && list.length &&\n            typeof list[0] === 'number') {\n            return [list];\n        }\n        return list.reduce(function (acc, item) {\n            if (Array.isArray(item) && Array.isArray(item[0])) {\n                return acc.concat(_flatten(item));\n            } else {\n                acc.push(item);\n                return acc;\n            }\n        }, []);\n    }\n};\n","var geojsonNormalize = require('@mapbox/geojson-normalize'),\n    geojsonFlatten = require('geojson-flatten'),\n    flatten = require('./flatten');\n\nmodule.exports = function(_) {\n    if (!_) return [];\n    var normalized = geojsonFlatten(geojsonNormalize(_)),\n        coordinates = [];\n    normalized.features.forEach(function(feature) {\n        if (!feature.geometry) return;\n        coordinates = coordinates.concat(flatten(feature.geometry.coordinates));\n    });\n    return coordinates;\n};\n","var geojsonCoords = require('@mapbox/geojson-coords'),\n    traverse = require('traverse'),\n    extent = require('@mapbox/extent');\n\nvar geojsonTypesByDataAttributes = {\n    features: ['FeatureCollection'],\n    coordinates: ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'],\n    geometry: ['Feature'],\n    geometries: ['GeometryCollection']\n}\n\nvar dataAttributes = Object.keys(geojsonTypesByDataAttributes);\n\nmodule.exports = function(_) {\n    return getExtent(_).bbox();\n};\n\nmodule.exports.polygon = function(_) {\n    return getExtent(_).polygon();\n};\n\nmodule.exports.bboxify = function(_) {\n    return traverse(_).map(function(value) {\n        if (!value) return ;\n\n        var isValid = dataAttributes.some(function(attribute){\n            if(value[attribute]) {\n                return geojsonTypesByDataAttributes[attribute].indexOf(value.type) !== -1;\n            }\n            return false;\n        });\n\n        if(isValid){\n            value.bbox = getExtent(value).bbox();\n            this.update(value);\n        }\n\n    });\n};\n\nfunction getExtent(_) {\n    var ext = extent(),\n        coords = geojsonCoords(_);\n    for (var i = 0; i < coords.length; i++) ext.include(coords[i]);\n    return ext;\n}\n","module.exports = normalize;\n\nvar types = {\n    Point: 'geometry',\n    MultiPoint: 'geometry',\n    LineString: 'geometry',\n    MultiLineString: 'geometry',\n    Polygon: 'geometry',\n    MultiPolygon: 'geometry',\n    GeometryCollection: 'geometry',\n    Feature: 'feature',\n    FeatureCollection: 'featurecollection'\n};\n\n/**\n * Normalize a GeoJSON feature into a FeatureCollection.\n *\n * @param {object} gj geojson data\n * @returns {object} normalized geojson data\n */\nfunction normalize(gj) {\n    if (!gj || !gj.type) return null;\n    var type = types[gj.type];\n    if (!type) return null;\n\n    if (type === 'geometry') {\n        return {\n            type: 'FeatureCollection',\n            features: [{\n                type: 'Feature',\n                properties: {},\n                geometry: gj\n            }]\n        };\n    } else if (type === 'feature') {\n        return {\n            type: 'FeatureCollection',\n            features: [gj]\n        };\n    } else if (type === 'featurecollection') {\n        return gj;\n    }\n}\n","export default function e(t){switch(t&&t.type||null){case\"FeatureCollection\":return t.features=t.features.reduce(function(t,r){return t.concat(e(r))},[]),t;case\"Feature\":return t.geometry?e(t.geometry).map(function(e){var r={type:\"Feature\",properties:JSON.parse(JSON.stringify(t.properties)),geometry:e};return void 0!==t.id&&(r.id=t.id),r}):[t];case\"MultiPoint\":return t.coordinates.map(function(e){return{type:\"Point\",coordinates:e}});case\"MultiPolygon\":return t.coordinates.map(function(e){return{type:\"Polygon\",coordinates:e}});case\"MultiLineString\":return t.coordinates.map(function(e){return{type:\"LineString\",coordinates:e}});case\"GeometryCollection\":return t.geometries.map(e).reduce(function(e,t){return e.concat(t)},[]);case\"Point\":case\"Polygon\":case\"LineString\":return[t]}}\n//# sourceMappingURL=index.es.js.map\n","var traverse = module.exports = function (obj) {\n    return new Traverse(obj);\n};\n\nfunction Traverse (obj) {\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.has = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!node || !hasOwnProperty.call(node, key)) {\n            return false;\n        }\n        node = node[key];\n    }\n    return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            forEach(objectKeys(src), function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var keepGoing = true;\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents[parents.length - 1],\n            parents : parents,\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x, stopHere) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) keepGoing = false;\n            },\n            'delete' : function (stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) keepGoing = false;\n            },\n            remove : function (stopHere) {\n                if (isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) keepGoing = false;\n            },\n            keys : null,\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false },\n            block : function () { keepGoing = false }\n        };\n        \n        if (!alive) return state;\n        \n        function updateState() {\n            if (typeof state.node === 'object' && state.node !== null) {\n                if (!state.keys || state.node_ !== state.node) {\n                    state.keys = objectKeys(state.node)\n                }\n                \n                state.isLeaf = state.keys.length == 0;\n                \n                for (var i = 0; i < parents.length; i++) {\n                    if (parents[i].node_ === node_) {\n                        state.circular = parents[i];\n                        break;\n                    }\n                }\n            }\n            else {\n                state.isLeaf = true;\n                state.keys = null;\n            }\n            \n            state.notLeaf = !state.isLeaf;\n            state.notRoot = !state.isRoot;\n        }\n        \n        updateState();\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        \n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (!keepGoing) return state;\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            updateState();\n            \n            forEach(state.keys, function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == state.keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (isArray(src)) {\n            dst = [];\n        }\n        else if (isDate(src)) {\n            dst = new Date(src.getTime ? src.getTime() : src);\n        }\n        else if (isRegExp(src)) {\n            dst = new RegExp(src);\n        }\n        else if (isError(src)) {\n            dst = { message: src.message };\n        }\n        else if (isBoolean(src)) {\n            dst = new Boolean(src);\n        }\n        else if (isNumber(src)) {\n            dst = new Number(src);\n        }\n        else if (isString(src)) {\n            dst = new String(src);\n        }\n        else if (Object.create && Object.getPrototypeOf) {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        else if (src.constructor === Object) {\n            dst = {};\n        }\n        else {\n            var proto =\n                (src.constructor && src.constructor.prototype)\n                || src.__proto__\n                || {}\n            ;\n            var T = function () {};\n            T.prototype = proto;\n            dst = new T;\n        }\n        \n        forEach(objectKeys(src), function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\nvar objectKeys = Object.keys || function keys (obj) {\n    var res = [];\n    for (var key in obj) res.push(key)\n    return res;\n};\n\nfunction toS (obj) { return Object.prototype.toString.call(obj) }\nfunction isDate (obj) { return toS(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toS(obj) === '[object RegExp]' }\nfunction isError (obj) { return toS(obj) === '[object Error]' }\nfunction isBoolean (obj) { return toS(obj) === '[object Boolean]' }\nfunction isNumber (obj) { return toS(obj) === '[object Number]' }\nfunction isString (obj) { return toS(obj) === '[object String]' }\n\nvar isArray = Array.isArray || function isArray (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nforEach(objectKeys(Traverse.prototype), function (key) {\n    traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = new Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\nvar hasOwnProperty = Object.hasOwnProperty || function (obj, key) {\n    return key in obj;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const classes = {\n  CONTROL_BASE: 'mapboxgl-ctrl',\n  CONTROL_PREFIX: 'mapboxgl-ctrl-',\n  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',\n  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',\n  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',\n  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',\n  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',\n  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',\n  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',\n  CONTROL_GROUP: 'mapboxgl-ctrl-group',\n  ATTRIBUTION: 'mapboxgl-ctrl-attrib',\n  ACTIVE_BUTTON: 'active',\n  BOX_SELECT: 'mapbox-gl-draw_boxselect'\n};\n\nexport const sources = {\n  HOT: 'mapbox-gl-draw-hot',\n  COLD: 'mapbox-gl-draw-cold'\n};\n\nexport const cursors = {\n  ADD: 'add',\n  MOVE: 'move',\n  DRAG: 'drag',\n  POINTER: 'pointer',\n  NONE: 'none'\n};\n\nexport const types = {\n  POLYGON: 'polygon',\n  LINE: 'line_string',\n  POINT: 'point'\n};\n\nexport const geojsonTypes = {\n  FEATURE: 'Feature',\n  POLYGON: 'Polygon',\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  FEATURE_COLLECTION: 'FeatureCollection',\n  MULTI_PREFIX: 'Multi',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon'\n};\n\nexport const modes = {\n  DRAW_LINE_STRING: 'draw_line_string',\n  DRAW_POLYGON: 'draw_polygon',\n  DRAW_POINT: 'draw_point',\n  SIMPLE_SELECT: 'simple_select',\n  DIRECT_SELECT: 'direct_select',\n  STATIC: 'static'\n};\n\nexport const events = {\n  CREATE: 'draw.create',\n  DELETE: 'draw.delete',\n  UPDATE: 'draw.update',\n  SELECTION_CHANGE: 'draw.selectionchange',\n  MODE_CHANGE: 'draw.modechange',\n  ACTIONABLE: 'draw.actionable',\n  RENDER: 'draw.render',\n  COMBINE_FEATURES: 'draw.combine',\n  UNCOMBINE_FEATURES: 'draw.uncombine'\n};\n\nexport const updateActions = {\n  MOVE: 'move',\n  CHANGE_COORDINATES: 'change_coordinates'\n};\n\nexport const meta = {\n  FEATURE: 'feature',\n  MIDPOINT: 'midpoint',\n  VERTEX: 'vertex'\n};\n\nexport const activeStates = {\n  ACTIVE: 'true',\n  INACTIVE: 'false'\n};\n\nexport const interactions = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate'\n];\n\nexport const LAT_MIN = -90;\nexport const LAT_RENDERED_MIN = -85;\nexport const LAT_MAX = 90;\nexport const LAT_RENDERED_MAX = 85;\nexport const LNG_MIN = -270;\nexport const LNG_MAX = 270;\n","export default {\n  enable(ctx) {\n    setTimeout(() => {\n      // First check we've got a map and some context.\n      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;\n      // Now check initial state wasn't false (we leave it disabled if so)\n      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;\n      ctx.map.doubleClickZoom.enable();\n    }, 0);\n  },\n  disable(ctx) {\n    setTimeout(() => {\n      if (!ctx.map || !ctx.map.doubleClickZoom) return;\n      // Always disable here, as it's necessary in some cases.\n      ctx.map.doubleClickZoom.disable();\n    }, 0);\n  }\n};\n","import * as Constants from '../constants';\n\nexport function isOfMetaType(type) {\n  return function(e) {\n    const featureTarget = e.featureTarget;\n    if (!featureTarget) return false;\n    if (!featureTarget.properties) return false;\n    return featureTarget.properties.meta === type;\n  };\n}\n\nexport function isShiftMousedown(e) {\n  if (!e.originalEvent) return false;\n  if (!e.originalEvent.shiftKey) return false;\n  return e.originalEvent.button === 0;\n}\n\nexport function isActiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isInactiveFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&\n    e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function noTarget(e) {\n  return e.featureTarget === undefined;\n}\n\nexport function isFeature(e) {\n  if (!e.featureTarget) return false;\n  if (!e.featureTarget.properties) return false;\n  return e.featureTarget.properties.meta === Constants.meta.FEATURE;\n}\n\nexport function isVertex(e) {\n  const featureTarget = e.featureTarget;\n  if (!featureTarget) return false;\n  if (!featureTarget.properties) return false;\n  return featureTarget.properties.meta === Constants.meta.VERTEX;\n}\n\nexport function isShiftDown(e) {\n  if (!e.originalEvent) return false;\n  return e.originalEvent.shiftKey === true;\n}\n\nexport function isEscapeKey(e) {\n  return e.keyCode === 27;\n}\n\nexport function isEnterKey(e) {\n  return e.keyCode === 13;\n}\n\nexport function isTrue() {\n  return true;\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport * as Constants from '../constants';\n\nconst DrawPoint = {};\n\nDrawPoint.onSetup = function() {\n  const point = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: []\n    }\n  });\n\n  this.addFeature(point);\n\n  this.clearSelectedFeatures();\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POINT);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return { point };\n};\n\nDrawPoint.stopDrawingAndRemove = function(state) {\n  this.deleteFeature([state.point.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawPoint.onTap = DrawPoint.onClick = function(state, e) {\n  this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);\n  this.map.fire(Constants.events.CREATE, {\n    features: [state.point.toGeoJSON()]\n  });\n  this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.point.id] });\n};\n\nDrawPoint.onStop = function(state) {\n  this.activateUIButton();\n  if (!state.point.getCoordinate().length) {\n    this.deleteFeature([state.point.id], { silent: true });\n  }\n};\n\nDrawPoint.toDisplayFeatures = function(state, geojson, display) {\n  // Never render the point we're drawing\n  const isActivePoint = geojson.properties.id === state.point.id;\n  geojson.properties.active = (isActivePoint) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePoint) return display(geojson);\n};\n\nDrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;\n\nDrawPoint.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e) || CommonSelectors.isEnterKey(e)) {\n    return this.stopDrawingAndRemove(state, e);\n  }\n};\n\nexport default DrawPoint;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { polygon, validateBBox } from '@turf/helpers';\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @name bboxPolygon\n * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    validateBBox(bbox);\n    // Convert BBox positions to Numbers\n    // No performance loss for including Number()\n    // https://github.com/Turfjs/turf/issues/1119\n    var west = Number(bbox[0]);\n    var south = Number(bbox[1]);\n    var east = Number(bbox[2]);\n    var north = Number(bbox[3]);\n\n    if (bbox.length === 6) throw new Error('@turf/bbox-polygon does not support BBox with 6 positions');\n\n    var lowLeft = [west, south];\n    var topLeft = [west, north];\n    var topRight = [east, north];\n    var lowRight = [east, south];\n\n    return polygon([[\n        lowLeft,\n        lowRight,\n        topRight,\n        topLeft,\n        lowLeft\n    ]]);\n}\n\nexport default bboxPolygon;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord, getCoords } from '@turf/invariant';\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    // Optional parameters\n    options = options || {};\n    if (typeof options !== 'object') throw new Error('options is invalid');\n    var ignoreBoundary = options.ignoreBoundary;\n\n    // validation\n    if (!point) throw new Error('point is required');\n    if (!polygon) throw new Error('polygon is required');\n\n    var pt = getCoord(point);\n    var polys = getCoords(polygon);\n    var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;\n    var bbox = polygon.bbox;\n\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) return false;\n\n    // normalize to multipolygon\n    if (type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n}\n\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);\n\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) return !ignoreBoundary;\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n           bbox[1] <= pt[1] &&\n           bbox[2] >= pt[0] &&\n           bbox[3] >= pt[1];\n}\n\nexport default booleanPointInPolygon;\n","import { feature, lineString } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, featureProperties, featureBBox, featureId);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, multiFeatureIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, multiFeatureIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature$$1, function (previousCoords, currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0);\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex);\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce };\n","function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","import rbush from './rbush';\nimport {featureEach, coordEach} from '@turf/meta';\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\nexport default geojsonRbush;\n","import { featureCollection, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    switch (geometry.type) {\n    case 'Polygon':\n        coords = getCoords(geometry);\n        break;\n    case 'LineString':\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\n\nexport default lineSegment;\n","import rbush from 'geojson-rbush';\nimport lineSegment from '@turf/line-segment';\nimport { getCoords } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport { feature, featureCollection, point } from '@turf/helpers';\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' &&\n        line2.type === 'Feature' &&\n        line1.geometry.type === 'LineString' &&\n        line2.geometry.type === 'LineString' &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return point([x, y]);\n    }\n    return null;\n}\n\nexport default lineIntersect;\n","import { getCoords, getType } from '@turf/invariant';\nimport { featureCollection, isObject, lineString, multiLineString } from '@turf/helpers';\n\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} polygon Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nfunction polygonToLine(polygon, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var properties = options.properties;\n\n    // Variables\n    var geom = getType(polygon);\n    var coords = getCoords(polygon);\n    properties = properties || polygon.properties || {};\n\n    if (!coords.length) throw new Error('polygon must contain coordinates');\n\n    switch (geom) {\n    case 'Polygon':\n        return coordsToLine(coords, properties);\n    case 'MultiPolygon':\n        var lines = [];\n        coords.forEach(function (coord) {\n            lines.push(coordsToLine(coord, properties));\n        });\n        return featureCollection(lines);\n    default:\n        throw new Error('geom ' + geom + ' not supported');\n    }\n}\n\nfunction coordsToLine(coords, properties) {\n    if (coords.length > 1) return multiLineString(coords, properties);\n    return lineString(coords[0], properties);\n}\n\nexport default polygonToLine;\n","import booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { flattenEach } from '@turf/meta';\nimport lineIntersect from '@turf/line-intersect';\nimport polygonToLine from '@turf/polygon-to-line';\n\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var boolean;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (boolean === false) return false;\n            boolean = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return boolean;\n}\n\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n    case 'Point':\n        switch (geom2.type) {\n        case 'Point':\n            return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case 'LineString':\n            return !isPointOnLine(geom2, geom1);\n        case 'Polygon':\n            return !booleanPointInPolygon(geom1, geom2);\n        }\n        /* istanbul ignore next */\n        break;\n    case 'LineString':\n        switch (geom2.type) {\n        case 'Point':\n            return !isPointOnLine(geom1, geom2);\n        case 'LineString':\n            return !isLineOnLine(geom1, geom2);\n        case 'Polygon':\n            return !isLineInPoly(geom2, geom1);\n        }\n        /* istanbul ignore next */\n        break;\n    case 'Polygon':\n        switch (geom2.type) {\n        case 'Point':\n            return !booleanPointInPolygon(geom2, geom1);\n        case 'LineString':\n            return !isLineInPoly(geom1, geom2);\n        case 'Polygon':\n            return !isPolyInPoly(geom2, geom1);\n        }\n    }\n}\n\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, point) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], point.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n\nfunction isLineInPoly(polygon, lineString) {\n    for (var i = 0; i < lineString.coordinates.length; i++) {\n        if (booleanPointInPolygon(lineString.coordinates[i], polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var i = 0; i < feature1.coordinates[0].length; i++) {\n        if (booleanPointInPolygon(feature1.coordinates[0][i], feature2)) {\n            return true;\n        }\n    }\n    for (var i2 = 0; i2 < feature2.coordinates[0].length; i2++) {\n        if (booleanPointInPolygon(feature2.coordinates[0][i2], feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n\nfunction isPointOnLineSegment(LineSegmentStart, LineSegmentEnd, Point) {\n    var dxc = Point[0] - LineSegmentStart[0];\n    var dyc = Point[1] - LineSegmentStart[1];\n    var dxl = LineSegmentEnd[0] - LineSegmentStart[0];\n    var dyl = LineSegmentEnd[1] - LineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return LineSegmentStart[0] <= Point[0] && Point[0] <= LineSegmentEnd[0];\n        } else {\n            return LineSegmentEnd[0] <= Point[0] && Point[0] <= LineSegmentStart[0];\n        }\n    } else if (dyl > 0) {\n        return LineSegmentStart[1] <= Point[1] && Point[1] <= LineSegmentEnd[1];\n    } else {\n        return LineSegmentEnd[1] <= Point[1] && Point[1] <= LineSegmentStart[1];\n    }\n}\n\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n\nexport default booleanDisjoint;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, lengthToRadians, point, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var properties = options.properties;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n\n    return point([lng, lat], properties);\n}\n\nexport default destination;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport lineIntersects from '@turf/line-intersect';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, lineString, point } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n\n    // validation\n    var type = (lines.geometry) ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, options);\n            // sectionLength\n            var sectionLength = distance(start, stop, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersects(\n                lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]),\n                lineString([start.geometry.coordinates, stop.geometry.coordinates])\n            );\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance(start, intersectPt, options);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n\n    });\n\n    return closestPt;\n}\n\nexport default nearestPointOnLine;\n","import bearing from '@turf/bearing';\nimport destination from '@turf/destination';\nimport distance from '@turf/distance';\n\n/**\n * Takes two {@link Point|points} and returns a point midway between them.\n * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.\n *\n * @name midpoint\n * @param {Coord} point1 first point\n * @param {Coord} point2 second point\n * @returns {Feature<Point>} a point midway between `pt1` and `pt2`\n * @example\n * var point1 = turf.point([144.834823, -37.771257]);\n * var point2 = turf.point([145.14244, -37.830937]);\n *\n * var midpoint = turf.midpoint(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2, midpoint];\n * midpoint.properties['marker-color'] = '#f00';\n */\nfunction midpoint(point1, point2) {\n    var dist = distance(point1, point2);\n    var heading = bearing(point1, point2);\n    var midpoint = destination(point1, dist / 2, heading);\n\n    return midpoint;\n}\n\nexport default midpoint;\n","// Heavily inspired from work of @davidgilbertson on Github and `leaflet-geoman` project.\n\nimport { geojsonTypes } from \"@mapbox/mapbox-gl-draw/src/constants\";\n// import {\n//   bboxPolygon,\n//   booleanDisjoint,\n//   getCoords,\n//   distance,\n//   polygonToLine,\n//   nearestPointOnLine,\n//   midpoint,\n// } from \"@turf/turf\";\n\nimport bboxPolygon from \"@turf/bbox-polygon\";\nimport booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { getCoords } from \"@turf/invariant\";\nimport distance from \"@turf/distance\";\nimport polygonToLine from \"@turf/polygon-to-line\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport midpoint from \"@turf/midpoint\";\nimport { lineString as turfLineString } from \"@turf/helpers\";\n\n\nexport const IDS = {\n  VERTICAL_GUIDE: \"VERTICAL_GUIDE\",\n  HORIZONTAL_GUIDE: \"HORIZONTAL_GUIDE\",\n};\n\nexport const addPointTovertices = (\n  map,\n  vertices,\n  coordinates,\n  forceInclusion\n) => {\n  const { width: w, height: h } = map.getCanvas();\n  // Just add verteices of features currently visible in viewport\n  const { x, y } = map.project(coordinates);\n  const pointIsOnTheScreen = x > 0 && x < w && y > 0 && y < h;\n\n  // But do add off-screen points if forced (e.g. for the current feature)\n  // So features will always snap to their own points\n  if (pointIsOnTheScreen || forceInclusion) {\n    vertices.push(coordinates);\n  }\n};\n\nexport const createSnapList = (map, draw, currentFeature) => {\n  // Get all drawn features\n  const features = draw.getAll().features;\n  const snapList = [];\n\n  // Get current bbox as polygon\n  const bboxAsPolygon = (() => {\n    const canvas = map.getCanvas(),\n      w = canvas.width,\n      h = canvas.height,\n      cUL = map.unproject([0, 0]).toArray(),\n      cUR = map.unproject([w, 0]).toArray(),\n      cLR = map.unproject([w, h]).toArray(),\n      cLL = map.unproject([0, h]).toArray();\n\n    return bboxPolygon([cLL, cUR].flat());\n  })();\n\n  const vertices = [];\n\n  // Keeps vertices for drwing guides\n  const addVerticesTovertices = (coordinates, isCurrentFeature = false) => {\n    if (!Array.isArray(coordinates)) throw Error(\"Your array is not an array\");\n\n    if (Array.isArray(coordinates[0])) {\n      // coordinates is an array of arrays, we must go deeper\n      coordinates.forEach((coord) => {\n        addVerticesTovertices(coord);\n      });\n    } else {\n      // If not an array of arrays, only consider arrays with two items\n      if (coordinates.length === 2) {\n        addPointTovertices(map, vertices, coordinates, isCurrentFeature);\n      }\n    }\n  };\n\n  features.forEach((feature) => {\n    // For currentfeature\n    if (feature.id === currentFeature.id) {\n      if (currentFeature.type === geojsonTypes.POLYGON) {\n        // For the current polygon, the last two points are the mouse position and back home\n        // so we chop those off (else we get vertices showing where the user clicked, even\n        // if they were just panning the map)\n        addVerticesTovertices(\n          feature.geometry.coordinates[0].slice(0, -2),\n          true\n        );\n      }\n      return;\n    }\n\n    // If this is re-running because a user is moving the map, the features might include\n    // vertices or the last leg of a polygon\n    if (\n      feature.id === IDS.HORIZONTAL_GUIDE ||\n      feature.id === IDS.VERTICAL_GUIDE\n    )\n      return;\n\n    addVerticesTovertices(feature.geometry.coordinates);\n\n    // If feature is currently on viewport add to snap list\n    if (!booleanDisjoint(bboxAsPolygon, feature)) {\n      snapList.push(feature);\n    }\n  });\n\n  return [snapList, vertices];\n};\n\nconst getNearbyvertices = (vertices, coords) => {\n  const verticals = [];\n  const horizontals = [];\n\n  vertices.forEach((vertex) => {\n    verticals.push(vertex[0]);\n    horizontals.push(vertex[1]);\n  });\n\n  const nearbyVerticalGuide = verticals.find(\n    (px) => Math.abs(px - coords.lng) < 0.009\n  );\n\n  const nearbyHorizontalGuide = horizontals.find(\n    (py) => Math.abs(py - coords.lat) < 0.009\n  );\n\n  return {\n    verticalPx: nearbyVerticalGuide,\n    horizontalPx: nearbyHorizontalGuide,\n  };\n};\n\nconst calcLayerDistances = (lngLat, layer) => {\n  // the point P which we want to snap (probpably the marker that is dragged)\n  const P = [lngLat.lng, lngLat.lat];\n\n  // is this a marker?\n  const isMarker = layer.geometry.type === \"Point\";\n  // is it a polygon?\n  const isPolygon = layer.geometry.type === \"Polygon\";\n  // is it a multiPolygon?\n  const isMultiPolygon = layer.geometry.type === \"MultiPolygon\";\n\n  let lines = undefined;\n\n  // the coords of the layer\n  const latlngs = getCoords(layer);\n\n  if (isMarker) {\n    const [lng, lat] = latlngs;\n    // return the info for the marker, no more calculations needed\n    return {\n      latlng: { lng, lat },\n      distance: distance(latlngs, P),\n    };\n  }\n\n  if (isPolygon || isMultiPolygon) {\n    lines = polygonToLine(layer);\n  } else {\n    lines = layer;\n  }\n\n  let nearestPoint;\n  if (isPolygon) {\n\n    let lineStrings;\n    if (lines.geometry.type === \"LineString\") {\n      lineStrings = [turfLineString(lines.geometry.coordinates)];\n    } else {\n      lineStrings = lines.geometry.coordinates.map((coords) =>\n        turfLineString(coords),\n      );\n    }\n\n    const closestFeature = getFeatureWithNearestPoint(lineStrings, P);\n    lines = closestFeature.feature;\n    nearestPoint = closestFeature.point;\n\n  } else if (isMultiPolygon) {\n\n    const lineStrings = lines.features\n      .map((feat) => {\n        if (feat.geometry.type === \"LineString\") {\n          return [feat.geometry.coordinates];\n        } else {\n          return feat.geometry.coordinates;\n        }\n      })\n      .flatMap((coords) => coords)\n      .map((coords) => turfLineString(coords));\n\n    const closestFeature = getFeatureWithNearestPoint(lineStrings, P);\n    lines = closestFeature.feature;\n    nearestPoint = closestFeature.point;\n\n  } else {\n    nearestPoint = nearestPointOnLine(lines, P);\n  }\n\n  const [lng, lat] = nearestPoint.geometry.coordinates;\n\n  let segmentIndex = nearestPoint.properties.index;\n  if (segmentIndex + 1 === lines.geometry.coordinates.length) segmentIndex--;\n\n  return {\n    latlng: { lng, lat },\n    segment: lines.geometry.coordinates.slice(segmentIndex, segmentIndex + 2),\n    distance: nearestPoint.properties.dist,\n    isMarker,\n  };\n};\n\nfunction getFeatureWithNearestPoint(lineStrings, P) {\n  const nearestPointsOfEachFeature = lineStrings.map((feat) => ({\n    feature: feat,\n    point: nearestPointOnLine(feat, P),\n  }));\n\n  nearestPointsOfEachFeature.sort(\n    (a, b) => a.point.properties.dist - b.point.properties.dist,\n  );\n\n  return {\n    feature: nearestPointsOfEachFeature[0].feature,\n    point: nearestPointsOfEachFeature[0].point,\n  };\n}\n\nconst calcClosestLayer = (lngLat, layers) => {\n  let closestLayer = {};\n\n  // loop through the layers\n  layers.forEach((layer, index) => {\n    // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n    const results = calcLayerDistances(lngLat, layer);\n\n    // save the info if it doesn't exist or if the distance is smaller than the previous one\n    if (\n      closestLayer.distance === undefined ||\n      results.distance < closestLayer.distance\n    ) {\n      closestLayer = results;\n      closestLayer.layer = layer;\n    }\n  });\n\n  // return the closest layer and it's data\n  // if there is no closest layer, return undefined\n  return closestLayer;\n};\n\n// minimal distance before marker snaps (in pixels)\nconst metersPerPixel = function (latitude, zoomLevel) {\n  const earthCircumference = 40075017;\n  const latitudeRadians = latitude * (Math.PI / 180);\n  return (\n    (earthCircumference * Math.cos(latitudeRadians)) /\n    Math.pow(2, zoomLevel + 8)\n  );\n};\n\n// we got the point we want to snap to (C), but we need to check if a coord of the polygon\nfunction snapToLineOrPolygon(closestLayer, snapOptions, snapVertexPriorityDistance) {\n  // A and B are the points of the closest segment to P (the marker position we want to snap)\n  const A = closestLayer.segment[0];\n  const B = closestLayer.segment[1];\n\n  // C is the point we would snap to on the segment.\n  // The closest point on the closest segment of the closest polygon to P. That's right.\n  const C = [closestLayer.latlng.lng, closestLayer.latlng.lat];\n\n  // distances from A to C and B to C to check which one is closer to C\n  const distanceAC = distance(A, C);\n  const distanceBC = distance(B, C);\n\n  // closest latlng of A and B to C\n  let closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n  // distance between closestVertexLatLng and C\n  let shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n  // snap to middle (M) of segment if option is enabled\n  if (snapOptions && snapOptions.snapToMidPoints) {\n    const M = midpoint(A, B).geometry.coordinates;\n    const distanceMC = distance(M, C);\n\n    if (distanceMC < distanceAC && distanceMC < distanceBC) {\n      // M is the nearest vertex\n      closestVertexLatLng = M;\n      shortestDistance = distanceMC;\n    }\n  }\n\n  // the distance that needs to be undercut to trigger priority\n  const priorityDistance = snapVertexPriorityDistance;\n\n  // the latlng we ultemately want to snap to\n  let snapLatlng;\n\n  // if C is closer to the closestVertexLatLng (A, B or M) than the snapDistance,\n  // the closestVertexLatLng has priority over C as the snapping point.\n  if (shortestDistance < priorityDistance) {\n    snapLatlng = closestVertexLatLng;\n  } else {\n    snapLatlng = C;\n  }\n\n  // return the copy of snapping point\n  const [lng, lat] = snapLatlng;\n  return {lng, lat};\n}\n\n\nfunction snapToPoint(closestLayer) {\n  return closestLayer.latlng;\n}\n\nconst checkPrioritiySnapping = (closestLayer, snapOptions, snapVertexPriorityDistance = 1.25) => {\n  let snappingToPoint = !Array.isArray(closestLayer.segment);\n  if (snappingToPoint) {\n    return snapToPoint(closestLayer);\n  } else {\n    return snapToLineOrPolygon(closestLayer, snapOptions, snapVertexPriorityDistance);\n  }\n};\n\n/**\n * Returns snap points if there are any, otherwise the original lng/lat of the event\n * Also, defines if vertices should show on the state object\n *\n * Mutates the state object\n *\n * @param state\n * @param e\n * @returns {{lng: number, lat: number}}\n */\nexport const snap = (state, e) => {\n  let lng = e.lngLat.lng;\n  let lat = e.lngLat.lat;\n\n  // Holding alt bypasses all snapping\n  if (e.originalEvent.altKey) {\n    state.showVerticalSnapLine = false;\n    state.showHorizontalSnapLine = false;\n\n    return { lng, lat };\n  }\n\n  if (state.snapList.length <= 0) {\n    return { lng, lat };\n  }\n\n  // snapping is on\n  let closestLayer, minDistance, snapLatLng;\n  if (state.options.snap) {\n    closestLayer = calcClosestLayer({ lng, lat }, state.snapList);\n\n    // if no layers found. Can happen when circle is the only visible layer on the map and the hidden snapping-border circle layer is also on the map\n    if (Object.keys(closestLayer).length === 0) {\n      return false;\n    }\n\n    const isMarker = closestLayer.isMarker;\n    const snapVertexPriorityDistance = state.options.snapOptions ? state.options.snapOptions.snapVertexPriorityDistance : undefined;\n\n    if (!isMarker) {\n      snapLatLng = checkPrioritiySnapping(\n        closestLayer,\n        state.options.snapOptions,\n        snapVertexPriorityDistance\n      );\n      // snapLatLng = closestLayer.latlng;\n    } else {\n      snapLatLng = closestLayer.latlng;\n    }\n\n    minDistance =\n      ((state.options.snapOptions && state.options.snapOptions.snapPx) || 15) *\n      metersPerPixel(snapLatLng.lat, state.map.getZoom());\n  }\n\n  let verticalPx, horizontalPx;\n  if (state.options.guides) {\n    const nearestGuidline = getNearbyvertices(state.vertices, e.lngLat);\n\n    verticalPx = nearestGuidline.verticalPx;\n    horizontalPx = nearestGuidline.horizontalPx;\n\n    if (verticalPx) {\n      // Draw a line from top to bottom\n\n      const lngLatTop = { lng: verticalPx, lat: e.lngLat.lat + 10 };\n      const lngLatBottom = { lng: verticalPx, lat: e.lngLat.lat - 10 };\n\n      state.verticalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.verticalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    if (horizontalPx) {\n      // Draw a line from left to right\n\n      const lngLatTop = { lng: e.lngLat.lng + 10, lat: horizontalPx };\n      const lngLatBottom = { lng: e.lngLat.lng - 10, lat: horizontalPx };\n\n      state.horizontalGuide.updateCoordinate(0, lngLatTop.lng, lngLatTop.lat);\n      state.horizontalGuide.updateCoordinate(\n        1,\n        lngLatBottom.lng,\n        lngLatBottom.lat\n      );\n    }\n\n    state.showVerticalSnapLine = !!verticalPx;\n    state.showHorizontalSnapLine = !!horizontalPx;\n  }\n\n  if (closestLayer && closestLayer.distance * 1000 < minDistance) {\n    return snapLatLng;\n  } else if (verticalPx || horizontalPx) {\n    if (verticalPx) {\n      lng = verticalPx;\n    }\n    if (horizontalPx) {\n      lat = horizontalPx;\n    }\n    return { lng, lat };\n  } else {\n    return { lng, lat };\n  }\n};\n\nexport const getGuideFeature = (id) => ({\n  id,\n  type: geojsonTypes.FEATURE,\n  properties: {\n    isSnapGuide: \"true\", // for styling\n  },\n  geometry: {\n    type: geojsonTypes.LINE_STRING,\n    coordinates: [],\n  },\n});\n\nexport const shouldHideGuide = (state, geojson) => {\n  if (\n    geojson.properties.id === IDS.VERTICAL_GUIDE &&\n    (!state.options.guides || !state.showVerticalSnapLine)\n  ) {\n    return true;\n  }\n\n  if (\n    geojson.properties.id === IDS.HORIZONTAL_GUIDE &&\n    (!state.options.guides || !state.showHorizontalSnapLine)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n","import { geojsonTypes, cursors } from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DrawPoint from \"@mapbox/mapbox-gl-draw/src/modes/draw_point\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapPointMode = { ...DrawPoint };\n\nSnapPointMode.onSetup = function (options) {\n  const point = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POINT,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(point);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, point);\n\n  const state = {\n    map: this.map,\n    point,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n  };\n\n  state.options = this._ctx.options;\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, point);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPointMode.onClick = function (state) {\n  // We mock out e with the rounded lng/lat then call DrawPoint with it\n  DrawPoint.onClick.call(this, state, {\n    lngLat: {\n      lng: state.snappedLng,\n      lat: state.snappedLat,\n    },\n  });\n};\n\nSnapPointMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPoint.toDisplayFeatures\nSnapPointMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapPointMode having a 'point' prop\n  DrawPoint.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPoint.onStop\nSnapPointMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n\n  // This relies on the the state of SnapPointMode having a 'point' prop\n  DrawPoint.onStop.call(this, state);\n};\n\nexport default SnapPointMode;\n","function isEventAtCoordinates(event, coordinates) {\n  if (!event.lngLat) return false;\n  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];\n}\n\nexport default isEventAtCoordinates;\n","import * as Constants from '../constants';\n\n/**\n * Returns GeoJSON for a Point representing the\n * vertex of another feature.\n *\n * @param {string} parentId\n * @param {Array<number>} coordinates\n * @param {string} path - Dot-separated numbers indicating exactly\n *   where the point exists within its parent feature's coordinates.\n * @param {boolean} selected\n * @return {GeoJSON} Point\n */\nexport default function(parentId, coordinates, path, selected) {\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.VERTEX,\n      parent: parentId,\n      coord_path: path,\n      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates\n    }\n  };\n}\n","import * as CommonSelectors from '../lib/common_selectors';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawLineString = {};\n\nDrawLineString.onSetup = function(opts) {\n  opts = opts || {};\n  const featureId = opts.featureId;\n\n  let line, currentVertexPosition;\n  let direction = 'forward';\n  if (featureId) {\n    line = this.getFeature(featureId);\n    if (!line) {\n      throw new Error('Could not find a feature with the provided featureId');\n    }\n    let from = opts.from;\n    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {\n      from = from.geometry;\n    }\n    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {\n      from = from.coordinates;\n    }\n    if (!from || !Array.isArray(from)) {\n      throw new Error('Please use the `from` property to indicate which point to continue the line from');\n    }\n    const lastCoord = line.coordinates.length - 1;\n    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {\n      currentVertexPosition = lastCoord + 1;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);\n    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {\n      direction = 'backwards';\n      currentVertexPosition = 0;\n      // add one new coordinate to continue from\n      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);\n    } else {\n      throw new Error('`from` should match the point at either the start or the end of the provided LineString');\n    }\n  } else {\n    line = this.newFeature({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: {},\n      geometry: {\n        type: Constants.geojsonTypes.LINE_STRING,\n        coordinates: []\n      }\n    });\n    currentVertexPosition = 0;\n    this.addFeature(line);\n  }\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.LINE);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    line,\n    currentVertexPosition,\n    direction\n  };\n};\n\nDrawLineString.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||\n      state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (state.direction === 'forward') {\n    state.currentVertexPosition++;\n    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  } else {\n    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);\n  }\n};\n\nDrawLineString.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n};\n\nDrawLineString.onMouseMove = function(state, e) {\n  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawLineString.onTap = DrawLineString.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  this.clickAnywhere(state, e);\n};\n\nDrawLineString.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });\n  } else if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  }\n};\n\nDrawLineString.onStop = function(state) {\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.line.id) === undefined) return;\n\n  //remove last added coordinate\n  state.line.removeCoordinate(`${state.currentVertexPosition}`);\n  if (state.line.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.line.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.line.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawLineString.onTrash = function(state) {\n  this.deleteFeature([state.line.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDrawLineString.toDisplayFeatures = function(state, geojson, display) {\n  const isActiveLine = geojson.properties.id === state.line.id;\n  geojson.properties.active = (isActiveLine) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActiveLine) return display(geojson);\n  // Only render the line if it has at least one real coordinate\n  if (geojson.geometry.coordinates.length < 2) return;\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(\n    state.line.id,\n    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],\n    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,\n    false\n  ));\n\n  display(geojson);\n};\n\nexport default DrawLineString;\n","import {\n  geojsonTypes,\n  modes,\n  cursors,\n} from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DrawLine from \"@mapbox/mapbox-gl-draw/src/modes/draw_line_string\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapLineMode = { ...DrawLine };\n\nSnapLineMode.onSetup = function (options) {\n  const line = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.LINE_STRING,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(line);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, line);\n\n  const state = {\n    map: this.map,\n    line,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n    direction: \"forward\", // expected by DrawLineString\n  };\n\n  state.options = this._ctx.options;\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(this.map, this._ctx.api, line);\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapLineMode.onClick = function (state) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  // Note: not bothering with 'direction'\n  if (state.currentVertexPosition > 0) {\n    const lastVertex = state.line.coordinates[state.currentVertexPosition - 1];\n\n    state.lastVertex = lastVertex;\n\n    if (lastVertex[0] === lng && lastVertex[1] === lat) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.line.id],\n      });\n    }\n  }\n\n  // const point = state.map.project({ lng: lng, lat: lat });\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n};\n\nSnapLineMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.line.updateCoordinate(state.currentVertexPosition, lng, lat);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawLine.toDisplayFeatures\nSnapLineMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapLineMode being similar to DrawLine\n  DrawLine.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawLine.onStop\nSnapLineMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n\n  // This relies on the the state of SnapLineMode being similar to DrawLine\n  DrawLine.onStop.call(this, state);\n};\n\nexport default SnapLineMode;\n","import * as CommonSelectors from '../lib/common_selectors';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport isEventAtCoordinates from '../lib/is_event_at_coordinates';\nimport createVertex from '../lib/create_vertex';\n\nconst DrawPolygon = {};\n\nDrawPolygon.onSetup = function() {\n  const polygon = this.newFeature({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POLYGON,\n      coordinates: [[]]\n    }\n  });\n\n  this.addFeature(polygon);\n\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  this.activateUIButton(Constants.types.POLYGON);\n  this.setActionableState({\n    trash: true\n  });\n\n  return {\n    polygon,\n    currentVertexPosition: 0\n  };\n};\n\nDrawPolygon.clickAnywhere = function(state, e) {\n  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {\n    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n  this.updateUIClasses({ mouse: Constants.cursors.ADD });\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  state.currentVertexPosition++;\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n};\n\nDrawPolygon.clickOnVertex = function(state) {\n  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n};\n\nDrawPolygon.onMouseMove = function(state, e) {\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);\n  if (CommonSelectors.isVertex(e)) {\n    this.updateUIClasses({ mouse: Constants.cursors.POINTER });\n  }\n};\n\nDrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {\n  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);\n  return this.clickAnywhere(state, e);\n};\n\nDrawPolygon.onKeyUp = function(state, e) {\n  if (CommonSelectors.isEscapeKey(e)) {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT);\n  } else if (CommonSelectors.isEnterKey(e)) {\n    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });\n  }\n};\n\nDrawPolygon.onStop = function(state) {\n  this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  doubleClickZoom.enable(this);\n  this.activateUIButton();\n\n  // check to see if we've deleted this feature\n  if (this.getFeature(state.polygon.id) === undefined) return;\n\n  //remove last added coordinate\n  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);\n  if (state.polygon.isValid()) {\n    this.map.fire(Constants.events.CREATE, {\n      features: [state.polygon.toGeoJSON()]\n    });\n  } else {\n    this.deleteFeature([state.polygon.id], { silent: true });\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });\n  }\n};\n\nDrawPolygon.toDisplayFeatures = function(state, geojson, display) {\n  const isActivePolygon = geojson.properties.id === state.polygon.id;\n  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;\n  if (!isActivePolygon) return display(geojson);\n\n  // Don't render a polygon until it has two positions\n  // (and a 3rd which is just the first repeated)\n  if (geojson.geometry.coordinates.length === 0) return;\n\n  const coordinateCount = geojson.geometry.coordinates[0].length;\n  // 2 coordinates after selecting a draw type\n  // 3 after creating the first point\n  if (coordinateCount < 3) {\n    return;\n  }\n  geojson.properties.meta = Constants.meta.FEATURE;\n  display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));\n  if (coordinateCount > 3) {\n    // Add a start position marker to the map, clicking on this will finish the feature\n    // This should only be shown when we're in a valid spot\n    const endPos = geojson.geometry.coordinates[0].length - 3;\n    display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));\n  }\n  if (coordinateCount <= 4) {\n    // If we've only drawn two positions (plus the closer),\n    // make a LineString instead of a Polygon\n    const lineCoordinates = [\n      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]\n    ];\n    // create an initial vertex so that we can track the first point on mobile devices\n    display({\n      type: Constants.geojsonTypes.FEATURE,\n      properties: geojson.properties,\n      geometry: {\n        coordinates: lineCoordinates,\n        type: Constants.geojsonTypes.LINE_STRING\n      }\n    });\n    if (coordinateCount === 3) {\n      return;\n    }\n  }\n  // render the Polygon\n  return display(geojson);\n};\n\nDrawPolygon.onTrash = function(state) {\n  this.deleteFeature([state.polygon.id], { silent: true });\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nexport default DrawPolygon;\n","import {\n  geojsonTypes,\n  modes,\n  cursors,\n} from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DrawPolygon from \"@mapbox/mapbox-gl-draw/src/modes/draw_polygon\";\nimport {\n  addPointTovertices,\n  createSnapList,\n  getGuideFeature,\n  IDS,\n  shouldHideGuide,\n  snap,\n} from \"./../utils\";\n\nconst SnapPolygonMode = { ...DrawPolygon };\n\nSnapPolygonMode.onSetup = function (options) {\n  const polygon = this.newFeature({\n    type: geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: geojsonTypes.POLYGON,\n      coordinates: [[]],\n    },\n  });\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(polygon);\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const selectedFeatures = this.getSelected();\n  this.clearSelectedFeatures();\n  doubleClickZoom.disable(this);\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, polygon);\n\n  const state = {\n    map: this.map,\n    polygon,\n    currentVertexPosition: 0,\n    vertices,\n    snapList,\n    selectedFeatures,\n    verticalGuide,\n    horizontalGuide,\n  };\n  state.options = this._ctx.options;\n\n  const moveendCallback = () => {\n    const [snapList, vertices] = createSnapList(\n      this.map,\n      this._ctx.api,\n      polygon\n    );\n    state.vertices = vertices;\n    state.snapList = snapList;\n  };\n  // for removing listener later on close\n  state[\"moveendCallback\"] = moveendCallback;\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n\n  this.map.on(\"moveend\", moveendCallback);\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapPolygonMode.onClick = function (state) {\n  // We save some processing by rounding on click, not mousemove\n  const lng = state.snappedLng;\n  const lat = state.snappedLat;\n\n  // End the drawing if this click is on the previous position\n  if (state.currentVertexPosition > 0) {\n    const lastVertex =\n      state.polygon.coordinates[0][state.currentVertexPosition - 1];\n\n    state.lastVertex = lastVertex;\n\n    if (lastVertex[0] === lng && lastVertex[1] === lat) {\n      return this.changeMode(modes.SIMPLE_SELECT, {\n        featureIds: [state.polygon.id],\n      });\n    }\n  }\n\n  // const point = state.map.project();\n\n  addPointTovertices(state.map, state.vertices, { lng, lat });\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n\n  state.currentVertexPosition++;\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n};\n\nSnapPolygonMode.onMouseMove = function (state, e) {\n  const { lng, lat } = snap(state, e);\n\n  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, lng, lat);\n  state.snappedLng = lng;\n  state.snappedLat = lat;\n\n  if (\n    state.lastVertex &&\n    state.lastVertex[0] === lng &&\n    state.lastVertex[1] === lat\n  ) {\n    this.updateUIClasses({ mouse: cursors.POINTER });\n\n    // cursor options:\n    // ADD: \"add\"\n    // DRAG: \"drag\"\n    // MOVE: \"move\"\n    // NONE: \"none\"\n    // POINTER: \"pointer\"\n  } else {\n    this.updateUIClasses({ mouse: cursors.ADD });\n  }\n};\n\n// This is 'extending' DrawPolygon.toDisplayFeatures\nSnapPolygonMode.toDisplayFeatures = function (state, geojson, display) {\n  if (shouldHideGuide(state, geojson)) return;\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DrawPolygon.toDisplayFeatures(state, geojson, display);\n};\n\n// This is 'extending' DrawPolygon.onStop\nSnapPolygonMode.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  this.map.off(\"moveend\", state.moveendCallback);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DrawPolygon.onStop.call(this, state);\n};\n\nexport default SnapPolygonMode;\n","import createVertex from './create_vertex';\nimport createMidpoint from './create_midpoint';\nimport * as Constants from '../constants';\n\nfunction createSupplementaryPoints(geojson, options = {}, basePath = null) {\n  const { type, coordinates } = geojson.geometry;\n  const featureId = geojson.properties && geojson.properties.id;\n\n  let supplementaryPoints = [];\n\n  if (type === Constants.geojsonTypes.POINT) {\n    // For points, just create a vertex\n    supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));\n  } else if (type === Constants.geojsonTypes.POLYGON) {\n    // Cycle through a Polygon's rings and\n    // process each line\n    coordinates.forEach((line, lineIndex) => {\n      processLine(line, (basePath !== null) ? `${basePath}.${lineIndex}` : String(lineIndex));\n    });\n  } else if (type === Constants.geojsonTypes.LINE_STRING) {\n    processLine(coordinates, basePath);\n  } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {\n    processMultiGeometry();\n  }\n\n  function processLine(line, lineBasePath) {\n    let firstPointString = '';\n    let lastVertex = null;\n    line.forEach((point, pointIndex) => {\n      const pointPath = (lineBasePath !== undefined && lineBasePath !== null) ? `${lineBasePath}.${pointIndex}` : String(pointIndex);\n      const vertex = createVertex(featureId, point, pointPath, isSelectedPath(pointPath));\n\n      // If we're creating midpoints, check if there was a\n      // vertex before this one. If so, add a midpoint\n      // between that vertex and this one.\n      if (options.midpoints && lastVertex) {\n        const midpoint = createMidpoint(featureId, lastVertex, vertex);\n        if (midpoint) {\n          supplementaryPoints.push(midpoint);\n        }\n      }\n      lastVertex = vertex;\n\n      // A Polygon line's last point is the same as the first point. If we're on the last\n      // point, we want to draw a midpoint before it but not another vertex on it\n      // (since we already a vertex there, from the first point).\n      const stringifiedPoint = JSON.stringify(point);\n      if (firstPointString !== stringifiedPoint) {\n        supplementaryPoints.push(vertex);\n      }\n      if (pointIndex === 0) {\n        firstPointString = stringifiedPoint;\n      }\n    });\n  }\n\n  function isSelectedPath(path) {\n    if (!options.selectedPaths) return false;\n    return options.selectedPaths.indexOf(path) !== -1;\n  }\n\n  // Split a multi-geometry into constituent\n  // geometries, and accumulate the supplementary points\n  // for each of those constituents\n  function processMultiGeometry() {\n    const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');\n    coordinates.forEach((subCoordinates, index) => {\n      const subFeature = {\n        type: Constants.geojsonTypes.FEATURE,\n        properties: geojson.properties,\n        geometry: {\n          type: subType,\n          coordinates: subCoordinates\n        }\n      };\n      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));\n    });\n  }\n\n  return supplementaryPoints;\n}\n\nexport default createSupplementaryPoints;\n","import * as Constants from '../constants';\n\nexport default function(parent, startVertex, endVertex) {\n  const startCoord = startVertex.geometry.coordinates;\n  const endCoord = endVertex.geometry.coordinates;\n\n  // If a coordinate exceeds the projection, we can't calculate a midpoint,\n  // so run away\n  if (startCoord[1] > Constants.LAT_RENDERED_MAX ||\n    startCoord[1] < Constants.LAT_RENDERED_MIN ||\n    endCoord[1] > Constants.LAT_RENDERED_MAX ||\n    endCoord[1] < Constants.LAT_RENDERED_MIN) {\n    return null;\n  }\n\n  const mid = {\n    lng: (startCoord[0] + endCoord[0]) / 2,\n    lat: (startCoord[1] + endCoord[1]) / 2\n  };\n\n  return {\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {\n      meta: Constants.meta.MIDPOINT,\n      parent,\n      lng: mid.lng,\n      lat: mid.lat,\n      coord_path: endVertex.properties.coord_path\n    },\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: [mid.lng, mid.lat]\n    }\n  };\n}\n","import extent from '@mapbox/geojson-extent';\nimport * as Constants from '../constants';\n\nconst {\n  LAT_MIN,\n  LAT_MAX,\n  LAT_RENDERED_MIN,\n  LAT_RENDERED_MAX,\n  LNG_MIN,\n  LNG_MAX\n} = Constants;\n\n// Ensure that we do not drag north-south far enough for\n// - any part of any feature to exceed the poles\n// - any feature to be completely lost in the space between the projection's\n//   edge and the poles, such that it couldn't be re-selected and moved back\nexport default function(geojsonFeatures, delta) {\n  // \"inner edge\" = a feature's latitude closest to the equator\n  let northInnerEdge = LAT_MIN;\n  let southInnerEdge = LAT_MAX;\n  // \"outer edge\" = a feature's latitude furthest from the equator\n  let northOuterEdge = LAT_MIN;\n  let southOuterEdge = LAT_MAX;\n\n  let westEdge = LNG_MAX;\n  let eastEdge = LNG_MIN;\n\n  geojsonFeatures.forEach((feature) => {\n    const bounds = extent(feature);\n    const featureSouthEdge = bounds[1];\n    const featureNorthEdge = bounds[3];\n    const featureWestEdge = bounds[0];\n    const featureEastEdge = bounds[2];\n    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;\n    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;\n    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;\n    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;\n    if (featureWestEdge < westEdge) westEdge = featureWestEdge;\n    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;\n  });\n\n\n  // These changes are not mutually exclusive: we might hit the inner\n  // edge but also have hit the outer edge and therefore need\n  // another readjustment\n  const constrainedDelta = delta;\n  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {\n    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;\n  }\n  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {\n    constrainedDelta.lat = LAT_MAX - northOuterEdge;\n  }\n  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {\n    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;\n  }\n  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {\n    constrainedDelta.lat = LAT_MIN - southOuterEdge;\n  }\n  if (westEdge + constrainedDelta.lng <= LNG_MIN) {\n    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {\n    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;\n  }\n\n  return constrainedDelta;\n}\n","import {noTarget, isOfMetaType, isActiveFeature, isInactiveFeature, isShiftDown} from '../lib/common_selectors';\nimport createSupplementaryPoints from '../lib/create_supplementary_points';\nimport constrainFeatureMovement from '../lib/constrain_feature_movement';\nimport doubleClickZoom from '../lib/double_click_zoom';\nimport * as Constants from '../constants';\nimport moveFeatures from '../lib/move_features';\n\nconst isVertex = isOfMetaType(Constants.meta.VERTEX);\nconst isMidpoint = isOfMetaType(Constants.meta.MIDPOINT);\n\nconst DirectSelect = {};\n\n// INTERNAL FUCNTIONS\n\nDirectSelect.fireUpdate = function() {\n  this.map.fire(Constants.events.UPDATE, {\n    action: Constants.updateActions.CHANGE_COORDINATES,\n    features: this.getSelected().map(f => f.toGeoJSON())\n  });\n};\n\nDirectSelect.fireActionable = function(state) {\n  this.setActionableState({\n    combineFeatures: false,\n    uncombineFeatures: false,\n    trash: state.selectedCoordPaths.length > 0\n  });\n};\n\nDirectSelect.startDragging = function(state, e) {\n  this.map.dragPan.disable();\n  state.canDragMove = true;\n  state.dragMoveLocation = e.lngLat;\n};\n\nDirectSelect.stopDragging = function(state) {\n  this.map.dragPan.enable();\n  state.dragMoving = false;\n  state.canDragMove = false;\n  state.dragMoveLocation = null;\n};\n\nDirectSelect.onVertex = function (state, e) {\n  this.startDragging(state, e);\n  const about = e.featureTarget.properties;\n  const selectedIndex = state.selectedCoordPaths.indexOf(about.coord_path);\n  if (!isShiftDown(e) && selectedIndex === -1) {\n    state.selectedCoordPaths = [about.coord_path];\n  } else if (isShiftDown(e) && selectedIndex === -1) {\n    state.selectedCoordPaths.push(about.coord_path);\n  }\n\n  const selectedCoordinates = this.pathsToCoordinates(state.featureId, state.selectedCoordPaths);\n  this.setSelectedCoordinates(selectedCoordinates);\n};\n\nDirectSelect.onMidpoint = function(state, e) {\n  this.startDragging(state, e);\n  const about = e.featureTarget.properties;\n  state.feature.addCoordinate(about.coord_path, about.lng, about.lat);\n  this.fireUpdate();\n  state.selectedCoordPaths = [about.coord_path];\n};\n\nDirectSelect.pathsToCoordinates = function(featureId, paths) {\n  return paths.map(coord_path => ({ feature_id: featureId, coord_path }));\n};\n\nDirectSelect.onFeature = function(state, e) {\n  if (state.selectedCoordPaths.length === 0) this.startDragging(state, e);\n  else this.stopDragging(state);\n};\n\nDirectSelect.dragFeature = function(state, e, delta) {\n  moveFeatures(this.getSelected(), delta);\n  state.dragMoveLocation = e.lngLat;\n};\n\nDirectSelect.dragVertex = function(state, e, delta) {\n  const selectedCoords = state.selectedCoordPaths.map(coord_path => state.feature.getCoordinate(coord_path));\n  const selectedCoordPoints = selectedCoords.map(coords => ({\n    type: Constants.geojsonTypes.FEATURE,\n    properties: {},\n    geometry: {\n      type: Constants.geojsonTypes.POINT,\n      coordinates: coords\n    }\n  }));\n\n  const constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);\n  for (let i = 0; i < selectedCoords.length; i++) {\n    const coord = selectedCoords[i];\n    state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);\n  }\n};\n\nDirectSelect.clickNoTarget = function () {\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDirectSelect.clickInactive = function () {\n  this.changeMode(Constants.modes.SIMPLE_SELECT);\n};\n\nDirectSelect.clickActiveFeature = function (state) {\n  state.selectedCoordPaths = [];\n  this.clearSelectedCoordinates();\n  state.feature.changed();\n};\n\n// EXTERNAL FUNCTIONS\n\nDirectSelect.onSetup = function(opts) {\n  const featureId = opts.featureId;\n  const feature = this.getFeature(featureId);\n\n  if (!feature) {\n    throw new Error('You must provide a featureId to enter direct_select mode');\n  }\n\n  if (feature.type === Constants.geojsonTypes.POINT) {\n    throw new TypeError('direct_select mode doesn\\'t handle point features');\n  }\n\n  const state = {\n    featureId,\n    feature,\n    dragMoveLocation: opts.startPos || null,\n    dragMoving: false,\n    canDragMove: false,\n    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : []\n  };\n\n  this.setSelectedCoordinates(this.pathsToCoordinates(featureId, state.selectedCoordPaths));\n  this.setSelected(featureId);\n  doubleClickZoom.disable(this);\n\n  this.setActionableState({\n    trash: true\n  });\n\n  return state;\n};\n\nDirectSelect.onStop = function() {\n  doubleClickZoom.enable(this);\n  this.clearSelectedCoordinates();\n};\n\nDirectSelect.toDisplayFeatures = function(state, geojson, push) {\n  if (state.featureId === geojson.properties.id) {\n    geojson.properties.active = Constants.activeStates.ACTIVE;\n    push(geojson);\n    createSupplementaryPoints(geojson, {\n      map: this.map,\n      midpoints: true,\n      selectedPaths: state.selectedCoordPaths\n    }).forEach(push);\n  } else {\n    geojson.properties.active = Constants.activeStates.INACTIVE;\n    push(geojson);\n  }\n  this.fireActionable(state);\n};\n\nDirectSelect.onTrash = function(state) {\n  // Uses number-aware sorting to make sure '9' < '10'. Comparison is reversed because we want them\n  // in reverse order so that we can remove by index safely.\n  state.selectedCoordPaths\n    .sort((a, b) => b.localeCompare(a, 'en', { numeric: true }))\n    .forEach(id => state.feature.removeCoordinate(id));\n  this.fireUpdate();\n  state.selectedCoordPaths = [];\n  this.clearSelectedCoordinates();\n  this.fireActionable(state);\n  if (state.feature.isValid() === false) {\n    this.deleteFeature([state.featureId]);\n    this.changeMode(Constants.modes.SIMPLE_SELECT, {});\n  }\n};\n\nDirectSelect.onMouseMove = function(state, e) {\n  // On mousemove that is not a drag, stop vertex movement.\n  const isFeature = isActiveFeature(e);\n  const onVertex = isVertex(e);\n  const noCoords = state.selectedCoordPaths.length === 0;\n  if (isFeature && noCoords) this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  else if (onVertex && !noCoords) this.updateUIClasses({ mouse: Constants.cursors.MOVE });\n  else this.updateUIClasses({ mouse: Constants.cursors.NONE });\n  this.stopDragging(state);\n\n  // Skip render\n  return true;\n};\n\nDirectSelect.onMouseOut = function(state) {\n  // As soon as you mouse leaves the canvas, update the feature\n  if (state.dragMoving) this.fireUpdate();\n\n  // Skip render\n  return true;\n};\n\nDirectSelect.onTouchStart = DirectSelect.onMouseDown = function(state, e) {\n  if (isVertex(e)) return this.onVertex(state, e);\n  if (isActiveFeature(e)) return this.onFeature(state, e);\n  if (isMidpoint(e)) return this.onMidpoint(state, e);\n};\n\nDirectSelect.onDrag = function(state, e) {\n  if (state.canDragMove !== true) return;\n  state.dragMoving = true;\n  e.originalEvent.stopPropagation();\n\n  const delta = {\n    lng: e.lngLat.lng - state.dragMoveLocation.lng,\n    lat: e.lngLat.lat - state.dragMoveLocation.lat\n  };\n  if (state.selectedCoordPaths.length > 0) this.dragVertex(state, e, delta);\n  else this.dragFeature(state, e, delta);\n\n  state.dragMoveLocation = e.lngLat;\n};\n\nDirectSelect.onClick = function(state, e) {\n  if (noTarget(e)) return this.clickNoTarget(state, e);\n  if (isActiveFeature(e)) return this.clickActiveFeature(state, e);\n  if (isInactiveFeature(e)) return this.clickInactive(state, e);\n  this.stopDragging(state);\n};\n\nDirectSelect.onTap = function(state, e) {\n  if (noTarget(e)) return this.clickNoTarget(state, e);\n  if (isActiveFeature(e)) return this.clickActiveFeature(state, e);\n  if (isInactiveFeature(e)) return this.clickInactive(state, e);\n};\n\nDirectSelect.onTouchEnd = DirectSelect.onMouseUp = function(state) {\n  if (state.dragMoving) {\n    this.fireUpdate();\n  }\n  this.stopDragging(state);\n};\n\nexport default DirectSelect;\n\n","import constrainFeatureMovement from './constrain_feature_movement';\nimport * as Constants from '../constants';\n\nexport default function(features, delta) {\n  const constrainedDelta = constrainFeatureMovement(features.map(feature => feature.toGeoJSON()), delta);\n\n  features.forEach((feature) => {\n    const currentCoordinates = feature.getCoordinates();\n\n    const moveCoordinate = (coord) => {\n      const point = {\n        lng: coord[0] + constrainedDelta.lng,\n        lat: coord[1] + constrainedDelta.lat\n      };\n      return [point.lng, point.lat];\n    };\n    const moveRing = ring => ring.map(coord => moveCoordinate(coord));\n    const moveMultiPolygon = multi => multi.map(ring => moveRing(ring));\n\n    let nextCoordinates;\n    if (feature.type === Constants.geojsonTypes.POINT) {\n      nextCoordinates = moveCoordinate(currentCoordinates);\n    } else if (feature.type === Constants.geojsonTypes.LINE_STRING || feature.type === Constants.geojsonTypes.MULTI_POINT) {\n      nextCoordinates = currentCoordinates.map(moveCoordinate);\n    } else if (feature.type === Constants.geojsonTypes.POLYGON || feature.type === Constants.geojsonTypes.MULTI_LINE_STRING) {\n      nextCoordinates = currentCoordinates.map(moveRing);\n    } else if (feature.type === Constants.geojsonTypes.MULTI_POLYGON) {\n      nextCoordinates = currentCoordinates.map(moveMultiPolygon);\n    }\n\n    feature.incomingCoords(nextCoordinates);\n  });\n}\n","import * as Constants from \"@mapbox/mapbox-gl-draw/src/constants\";\nimport doubleClickZoom from \"@mapbox/mapbox-gl-draw/src/lib/double_click_zoom\";\nimport DirectSelect from \"@mapbox/mapbox-gl-draw/src/modes/direct_select\";\nimport { createSnapList, getGuideFeature, IDS, snap } from \"./../utils\";\n\nconst SnapDirectSelect = { ...DirectSelect };\n\nSnapDirectSelect.onSetup = function (opts) {\n  const featureId = opts.featureId;\n  const feature = this.getFeature(featureId);\n\n  if (!feature) {\n    throw new Error(\"You must provide a featureId to enter direct_select mode\");\n  }\n\n  if (feature.type === Constants.geojsonTypes.POINT) {\n    throw new TypeError(\"direct_select mode doesn't handle point features\");\n  }\n\n  const [snapList, vertices] = createSnapList(this.map, this._ctx.api, feature);\n\n  const verticalGuide = this.newFeature(getGuideFeature(IDS.VERTICAL_GUIDE));\n  const horizontalGuide = this.newFeature(\n    getGuideFeature(IDS.HORIZONTAL_GUIDE)\n  );\n\n  this.addFeature(verticalGuide);\n  this.addFeature(horizontalGuide);\n\n  const state = {\n    map: this.map,\n    featureId,\n    feature,\n    dragMoveLocation: opts.startPos || null,\n    dragMoving: false,\n    canDragMove: false,\n    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : [],\n    vertices,\n    snapList,\n    verticalGuide,\n    horizontalGuide,\n  };\n\n  state.options = this._ctx.options;\n\n  this.setSelectedCoordinates(\n    this.pathsToCoordinates(featureId, state.selectedCoordPaths)\n  );\n  this.setSelected(featureId);\n  doubleClickZoom.disable(this);\n\n  this.setActionableState({\n    trash: true,\n  });\n\n  const optionsChangedCallBAck = (options) => {\n    state.options = options;\n  };\n\n  // for removing listener later on close\n  state[\"optionsChangedCallBAck\"] = optionsChangedCallBAck;\n  this.map.on(\"draw.snap.options_changed\", optionsChangedCallBAck);\n\n  return state;\n};\n\nSnapDirectSelect.dragVertex = function (state, e, delta) {\n  const { lng, lat } = snap(state, e);\n\n  state.feature.updateCoordinate(state.selectedCoordPaths[0], lng, lat);\n};\n\nSnapDirectSelect.onStop = function (state) {\n  this.deleteFeature(IDS.VERTICAL_GUIDE, { silent: true });\n  this.deleteFeature(IDS.HORIZONTAL_GUIDE, { silent: true });\n\n  // remove moveemd callback\n  //   this.map.off(\"moveend\", state.moveendCallback);\n  this.map.off(\"draw.snap.options_changed\", state.optionsChangedCallBAck);\n\n  // This relies on the the state of SnapPolygonMode being similar to DrawPolygon\n  DirectSelect.onStop.call(this, state);\n};\n\nexport default SnapDirectSelect;\n","import theme from '@mapbox/mapbox-gl-draw/src/lib/theme';\n\nconst modifiedDefaultStyles = theme.map(defaultStyle => {\n  if (defaultStyle.id === 'gl-draw-line-inactive') {\n    return {\n      ...defaultStyle,\n      filter: [\n        ...defaultStyle.filter,\n        ['!=', 'user_isSnapGuide', 'true'],\n      ],\n    };\n  }\n\n  return defaultStyle;\n});\n\nconst customDrawStyles = [\n  ...modifiedDefaultStyles,\n  {\n    id: \"guide\",\n    type: \"line\",\n    filter: [\n      \"all\",\n      [\"==\", \"$type\", \"LineString\"],\n      [\"==\", \"user_isSnapGuide\", \"true\"],\n    ],\n    layout: {\n      \"line-cap\": \"round\",\n      \"line-join\": \"round\",\n    },\n    paint: {\n      \"line-color\": \"#c00c00\",\n      \"line-width\": 1,\n      \"line-dasharray\": [5, 5],\n    },\n  },\n];\n\nexport default customDrawStyles;\n","export default [\n  {\n    'id': 'gl-draw-polygon-fill-inactive',\n    'type': 'fill',\n    'filter': ['all',\n      ['==', 'active', 'false'],\n      ['==', '$type', 'Polygon'],\n      ['!=', 'mode', 'static']\n    ],\n    'paint': {\n      'fill-color': '#3bb2d0',\n      'fill-outline-color': '#3bb2d0',\n      'fill-opacity': 0.1\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-fill-active',\n    'type': 'fill',\n    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],\n    'paint': {\n      'fill-color': '#fbb03b',\n      'fill-outline-color': '#fbb03b',\n      'fill-opacity': 0.1\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-midpoint',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'midpoint']],\n    'paint': {\n      'circle-radius': 3,\n      'circle-color': '#fbb03b'\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-stroke-inactive',\n    'type': 'line',\n    'filter': ['all',\n      ['==', 'active', 'false'],\n      ['==', '$type', 'Polygon'],\n      ['!=', 'mode', 'static']\n    ],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round'\n    },\n    'paint': {\n      'line-color': '#3bb2d0',\n      'line-width': 2\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-stroke-active',\n    'type': 'line',\n    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round'\n    },\n    'paint': {\n      'line-color': '#fbb03b',\n      'line-dasharray': [0.2, 2],\n      'line-width': 2\n    }\n  },\n  {\n    'id': 'gl-draw-line-inactive',\n    'type': 'line',\n    'filter': ['all',\n      ['==', 'active', 'false'],\n      ['==', '$type', 'LineString'],\n      ['!=', 'mode', 'static']\n    ],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round'\n    },\n    'paint': {\n      'line-color': '#3bb2d0',\n      'line-width': 2\n    }\n  },\n  {\n    'id': 'gl-draw-line-active',\n    'type': 'line',\n    'filter': ['all',\n      ['==', '$type', 'LineString'],\n      ['==', 'active', 'true']\n    ],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round'\n    },\n    'paint': {\n      'line-color': '#fbb03b',\n      'line-dasharray': [0.2, 2],\n      'line-width': 2\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-and-line-vertex-stroke-inactive',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', 'meta', 'vertex'],\n      ['==', '$type', 'Point'],\n      ['!=', 'mode', 'static']\n    ],\n    'paint': {\n      'circle-radius': 5,\n      'circle-color': '#fff'\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-and-line-vertex-inactive',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', 'meta', 'vertex'],\n      ['==', '$type', 'Point'],\n      ['!=', 'mode', 'static']\n    ],\n    'paint': {\n      'circle-radius': 3,\n      'circle-color': '#fbb03b'\n    }\n  },\n  {\n    'id': 'gl-draw-point-point-stroke-inactive',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', 'active', 'false'],\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'feature'],\n      ['!=', 'mode', 'static']\n    ],\n    'paint': {\n      'circle-radius': 5,\n      'circle-opacity': 1,\n      'circle-color': '#fff'\n    }\n  },\n  {\n    'id': 'gl-draw-point-inactive',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', 'active', 'false'],\n      ['==', '$type', 'Point'],\n      ['==', 'meta', 'feature'],\n      ['!=', 'mode', 'static']\n    ],\n    'paint': {\n      'circle-radius': 3,\n      'circle-color': '#3bb2d0'\n    }\n  },\n  {\n    'id': 'gl-draw-point-stroke-active',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', '$type', 'Point'],\n      ['==', 'active', 'true'],\n      ['!=', 'meta', 'midpoint']\n    ],\n    'paint': {\n      'circle-radius': 7,\n      'circle-color': '#fff'\n    }\n  },\n  {\n    'id': 'gl-draw-point-active',\n    'type': 'circle',\n    'filter': ['all',\n      ['==', '$type', 'Point'],\n      ['!=', 'meta', 'midpoint'],\n      ['==', 'active', 'true']],\n    'paint': {\n      'circle-radius': 5,\n      'circle-color': '#fbb03b'\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-fill-static',\n    'type': 'fill',\n    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],\n    'paint': {\n      'fill-color': '#404040',\n      'fill-outline-color': '#404040',\n      'fill-opacity': 0.1\n    }\n  },\n  {\n    'id': 'gl-draw-polygon-stroke-static',\n    'type': 'line',\n    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round'\n    },\n    'paint': {\n      'line-color': '#404040',\n      'line-width': 2\n    }\n  },\n  {\n    'id': 'gl-draw-line-static',\n    'type': 'line',\n    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'LineString']],\n    'layout': {\n      'line-cap': 'round',\n      'line-join': 'round'\n    },\n    'paint': {\n      'line-color': '#404040',\n      'line-width': 2\n    }\n  },\n  {\n    'id': 'gl-draw-point-static',\n    'type': 'circle',\n    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Point']],\n    'paint': {\n      'circle-radius': 5,\n      'circle-color': '#404040'\n    }\n  }\n];\n"],"names":["root","factory","exports","module","define","amd","this","Extent","bbox","_bbox","Infinity","_valid","prototype","include","ll","Math","min","max","equals","_","other","center","union","contains","_fastContains","lon","lat","intersect","Function","body","polygon","type","coordinates","list","_flatten","Array","isArray","length","reduce","acc","item","concat","push","geojsonNormalize","geojsonFlatten","flatten","normalized","features","forEach","feature","geometry","geojsonCoords","traverse","extent","geojsonTypesByDataAttributes","geometries","dataAttributes","Object","keys","getExtent","ext","coords","i","bboxify","map","value","some","attribute","indexOf","update","gj","types","properties","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","Feature","FeatureCollection","e","t","r","JSON","parse","stringify","id","obj","Traverse","walk","cb","immutable","path","parents","alive","walker","node_","node","copy","modifiers","keepGoing","state","parent","key","slice","isRoot","level","circular","x","stopHere","remove","splice","before","f","after","pre","post","stop","block","updateState","objectKeys","isLeaf","notLeaf","notRoot","ret","call","undefined","child","hasOwnProperty","isLast","isFirst","pop","src","dst","toS","Date","getTime","isRegExp","RegExp","isError","message","isBoolean","Boolean","isNumber","Number","isString","String","create","getPrototypeOf","constructor","proto","__proto__","T","get","ps","has","set","init","skip","arguments","paths","nodes","clone","res","toString","xs","fn","args","apply","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","prop","Symbol","toStringTag","classes","CONTROL_BASE","CONTROL_PREFIX","CONTROL_BUTTON","CONTROL_BUTTON_LINE","CONTROL_BUTTON_POLYGON","CONTROL_BUTTON_POINT","CONTROL_BUTTON_TRASH","CONTROL_BUTTON_COMBINE_FEATURES","CONTROL_BUTTON_UNCOMBINE_FEATURES","CONTROL_GROUP","ATTRIBUTION","ACTIVE_BUTTON","BOX_SELECT","sources","HOT","COLD","cursors","ADD","MOVE","DRAG","POINTER","NONE","POLYGON","LINE","POINT","geojsonTypes","FEATURE","LINE_STRING","FEATURE_COLLECTION","MULTI_PREFIX","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","modes","DRAW_LINE_STRING","DRAW_POLYGON","DRAW_POINT","SIMPLE_SELECT","DIRECT_SELECT","STATIC","events","CREATE","DELETE","UPDATE","SELECTION_CHANGE","MODE_CHANGE","ACTIONABLE","RENDER","COMBINE_FEATURES","UNCOMBINE_FEATURES","updateActions","CHANGE_COORDINATES","meta","MIDPOINT","VERTEX","activeStates","ACTIVE","INACTIVE","interactions","LAT_MIN","LAT_RENDERED_MIN","LAT_MAX","LAT_RENDERED_MAX","LNG_MIN","LNG_MAX","enable","ctx","setTimeout","doubleClickZoom","_ctx","store","getInitialConfigValue","disable","isOfMetaType","featureTarget","isActiveFeature","active","isInactiveFeature","noTarget","isVertex","isShiftDown","originalEvent","shiftKey","isEscapeKey","keyCode","isEnterKey","DrawPoint","point","newFeature","addFeature","clearSelectedFeatures","updateUIClasses","mouse","activateUIButton","setActionableState","trash","deleteFeature","silent","changeMode","onTap","onClick","updateCoordinate","lngLat","lng","fire","toGeoJSON","featureIds","onStop","getCoordinate","toDisplayFeatures","geojson","display","isActivePoint","onTrash","stopDrawingAndRemove","onKeyUp","earthRadius","factors","meters","metres","millimeters","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","options","isObject","Error","validateBBox","validateId","feat","ring","j","featureCollection","fc","multiLineString","radiansToLength","units","factor","lengthToRadians","distance","radiansToDegrees","PI","degreesToRadians","num","isNaN","input","west","south","east","north","lowLeft","getCoord","getCoords","containsNumber","inRing","pt","ignoreBoundary","isInside","xi","yi","xj","yj","polys","inBBox","insidePoly","inHole","k","coordEach","callback","excludeWrapCoord","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","geomEach","g","featureProperties","featureBBox","featureId","flattenEach","coordinate","quickselectStep","arr","left","right","compare","m","z","log","s","exp","sd","sqrt","floor","swap","tmp","defaultCompare","b","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","clear","findItem","items","equalsFn","calcBBox","toBBox","distBBox","children","p","destNode","createNode","minX","minY","maxX","maxY","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","height","multiSelect","mid","stack","all","_all","data","search","result","len","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","index","goingUp","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","N","M","pow","right2","right3","N2","N1","_chooseSubtree","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","join","topLeft","topRight","turfBBox","coord","tree","json","results","segments","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","line1","line2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","unique","match","coordsToLine","geom","name","getType","lines","isPointOnLine","lineString","isPointOnLineSegment","isLineInPoly","LineSegmentStart","LineSegmentEnd","dxc","dyc","dxl","dyl","abs","feature1","feature2","boolean","flatten1","flatten2","geom1","geom2","pair1","pair2","lineString1","lineString2","isLineOnLine","i2","isPolyInPoly","disjoint","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","sin","cos","atan2","bearing","start","end","final","bear","calculateFinalBearing","lon1","lon2","origin","longitude1","latitude1","bearing_rad","latitude2","asin","closestPt","dist","line","sectionLength","heightDistance","direction","perpendicularPt1","perpendicularPt2","intersectPt","location","point1","point2","heading","IDS","addPointTovertices","vertices","forceInclusion","getCanvas","w","width","h","project","y","createSnapList","draw","currentFeature","canvas","cUR","cLL","getAll","snapList","bboxAsPolygon","unproject","toArray","bboxPolygon","flat","addVerticesTovertices","isCurrentFeature","booleanDisjoint","getFeatureWithNearestPoint","lineStrings","P","nearestPointsOfEachFeature","nearestPointOnLine","calcClosestLayer","layers","closestLayer","layer","nearestPoint","isMarker","isPolygon","isMultiPolygon","latlngs","latlng","polygonToLine","closestFeature","turfLineString","flatMap","segmentIndex","calcLayerDistances","snapToLineOrPolygon","snapOptions","snapVertexPriorityDistance","A","B","C","distanceAC","distanceBC","closestVertexLatLng","shortestDistance","snapToMidPoints","midpoint","distanceMC","snapToPoint","snap","minDistance","snapLatLng","latitude","zoomLevel","latitudeRadians","verticalPx","horizontalPx","verticals","horizontals","altKey","showVerticalSnapLine","showHorizontalSnapLine","checkPrioritiySnapping","snapPx","getZoom","guides","nearestGuidline","vertex","find","px","py","lngLatTop","lngLatBottom","verticalGuide","horizontalGuide","getGuideFeature","isSnapGuide","shouldHideGuide","SnapPointMode","onSetup","selectedFeatures","getSelected","api","moveendCallback","optionsChangedCallBAck","on","snappedLng","snappedLat","onMouseMove","lastVertex","off","event","parentId","selected","coord_path","DrawLineString","opts","currentVertexPosition","getFeature","lastCoord","addCoordinate","clickOnVertex","clickAnywhere","removeCoordinate","isValid","isActiveLine","SnapLineMode","DrawLine","DrawPolygon","isActivePolygon","coordinateCount","endPos","lineCoordinates","SnapPolygonMode","createSupplementaryPoints","basePath","supplementaryPoints","processLine","lineBasePath","firstPointString","pointIndex","pointPath","isSelectedPath","midpoints","startVertex","endVertex","startCoord","endCoord","stringifiedPoint","selectedPaths","lineIndex","subType","replace","subCoordinates","subFeature","processMultiGeometry","geojsonFeatures","delta","northInnerEdge","southInnerEdge","northOuterEdge","southOuterEdge","westEdge","eastEdge","bounds","featureSouthEdge","featureNorthEdge","featureWestEdge","featureEastEdge","constrainedDelta","isMidpoint","DirectSelect","action","combineFeatures","uncombineFeatures","selectedCoordPaths","dragPan","canDragMove","dragMoveLocation","dragMoving","startDragging","about","selectedIndex","selectedCoordinates","pathsToCoordinates","setSelectedCoordinates","fireUpdate","feature_id","stopDragging","dragFeature","currentCoordinates","getCoordinates","moveCoordinate","moveRing","moveMultiPolygon","multi","nextCoordinates","incomingCoords","dragVertex","selectedCoords","clickNoTarget","clickInactive","clickActiveFeature","clearSelectedCoordinates","changed","TypeError","startPos","coordPath","setSelected","fireActionable","localeCompare","numeric","onVertex","noCoords","onMouseOut","onTouchStart","onMouseDown","onFeature","onMidpoint","onDrag","stopPropagation","onTouchEnd","onMouseUp","SnapDirectSelect","Constants","modifiedDefaultStyles","defaultStyle","filter","layout","paint"],"sourceRoot":""}